// Siemens А70 - PCF8812 -  HP10534 
// http://we.easyelectronics.ru/STM8/metody-energosberezheniya-v-stm8l.html


#include "halLCD.h"
#include "defines.h"
#include "board.h"
#include "modPaint.h"
#include "modPaint_local.h"

#include <string.h> // for memset
#include "debug.h"

#include "halSPI.h"


#if (LCD_PCD8812)

// структура параметров дисплея
struct halLCD_lcdStruct_t {
	uint8_t       orientation; // Ориентация
    color_t       color;
} halLCD_lcdStruct;


// некалиброванная задержка для процедуры инициализации LCD
void halLCD_delay (uint32_t delay) {
    delay = delay * 1000UL;
    while (delay){ delay--; }
}


void halLCD_setColor (color_t color) {
    halLCD_lcdStruct.color = color;
}


uint8_t LCD_pixel_mode = GDI_ROP_COPY;
uint8_t LCD_buf[101][8];
uint8_t LCD_update_pos = 0;




// static const char picture [808] = {
// 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0x7f,0x7f,0x7f,0xbf,0x0f,0x03,0x49,0x89,0x95,0x52,0xa5,0xc5,0xca,0x95,0xa9,0xc2,
//        0x95,0xca,0xa5,0x82,0x84,0x20,0x01,0x2a,0x0f,0x0f,0x1f,0x2f,0x5f,0x9f,0x1f,0x3f,
//        0x1f,0x1f,0x9f,0xdf,0x7f,0xbf,0x7f,0xdf,0x7f,0xdf,0xbf,0xbf,0x7f,0xbf,0xff,0xbf,
//        0x7f,0xff,0x7f,0xff,0x7f,

//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,0xff,0xbf,0x7f,0xff,0x9f,0x7f,
//        0xef,0xdf,0x2f,0xf7,0x2f,0x4f,0x6f,0xcf,0x13,0x53,0x03,0x01,0x43,0x11,0x08,0x02,
//        0x01,0x38,0xfc,0x66,0x9a,0x7f,0xeb,0x94,0x65,0xeb,0x54,0xaa,0x74,0xcb,0xb2,0x6d,
//        0xd3,0x34,0x6b,0x35,0x1b,0x0f,0x16,0x00,0x00,0x01,0x00,0x04,0x20,0x00,0x08,0x00,
//        0x63,0x0c,0x96,0x29,0x12,0x4d,0x33,0x46,0xad,0x1b,0x65,0x9b,0x67,0x5c,0xab,0x55,
//        0xae,0x59,0x67,0x8c,0x5b,

//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf5,0x8a,0x77,0xac,0x4b,0x95,0x29,0x53,0x06,
//        0x39,0x84,0x45,0xe8,0xd1,0x33,0xf2,0xa8,0x75,0xe0,0xa0,0xd2,0x80,0x80,0x04,0x40,
//        0x00,0x80,0x40,0x81,0x00,0x81,0x81,0x00,0x81,0x80,0x81,0x80,0x41,0x80,0xc0,0x80,
//        0xc0,0xe0,0x80,0x80,0x88,0x00,0x00,0x30,0x64,0x30,0xf1,0x98,0x6c,0x7e,0xa5,0xdf,
//        0x5b,0xb5,0x37,0xa6,0x5d,0xaa,0x50,0x01,0x00,0x09,0x22,0x88,0x51,0x26,0x0a,0x75,
//        0x4a,0xb5,0x4a,0xb5,0x25,

//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf4,0xc9,0x36,0x0a,0x11,0x02,0x44,
//        0x10,0x00,0x07,0x2c,0x59,0x27,0x6c,0x9b,0xd3,0x0c,0x03,0xc0,0x79,0x8d,0xf4,0x1a,
//        0xef,0xb5,0x5b,0xed,0xbb,0x4d,0xff,0x69,0xd7,0xbe,0xd5,0xbb,0x6d,0xd7,0x3a,0xed,
//        0x56,0xae,0xd5,0x5b,0xb5,0x66,0x9a,0x6c,0x98,0x00,0x00,0x00,0x0b,0x73,0x14,0x0e,
//        0x11,0x06,0x0d,0x01,0x02,0x02,0x00,0x40,0x00,0x00,0x04,0x00,0x00,0x00,0x24,0x00,
//        0x08,0x12,0x11,0xbe,0xff,

//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf6,0xc0,0x80,
//        0x14,0x20,0x51,0x84,0x00,0x10,0x00,0x00,0x00,0x01,0x00,0x2b,0x54,0xab,0x52,0xad,
//        0x56,0xa9,0x56,0xad,0x5a,0xd3,0x2e,0xd5,0x2a,0xd7,0xac,0x32,0xcf,0x3a,0xa5,0x56,
//        0x6b,0x95,0x6a,0x55,0xaa,0x55,0xaa,0x55,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//        0x09,0x00,0x80,0x40,0x80,0x60,0xc0,0x40,0x80,0x80,0x00,0x00,0x02,0x00,0x00,0x90,
//        0x48,0x26,0xfb,0xff,0xff,

//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xf8,0x40,0x03,0x24,0xfa,0x6c,0x17,0xe8,0x98,0x52,0xa0,0x80,0x00,0x01,0x01,0x06,
//        0x19,0x2a,0xd5,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x4a,0xb5,0xaa,0x55,0xab,0x54,
//        0xab,0x5d,0xa2,0x6d,0x1a,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0xc8,0x35,
//        0xd2,0x2e,0x25,0x49,0x92,0x25,0x42,0x99,0x66,0xb5,0x4c,0x00,0x00,0x00,0x00,0x04,
//        0x82,0x85,0x1f,0x7f,0xbf,

//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xe3,0x08,0x90,0x48,0x23,0x87,0x1c,0x72,0xc9,0x04,0x92,0x21,0x16,0xcc,0x30,0x40,
//        0x00,0x00,0x00,0x03,0x0e,0x19,0x32,0x4d,0xd2,0x2d,0x52,0xad,0x52,0xad,0x12,0x2d,
//        0x0a,0x05,0x0a,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0x95,0x6b,0x94,0x2b,
//        0x42,0x95,0x28,0x41,0x26,0x88,0x11,0xe3,0x1c,0x03,0x00,0x00,0xc0,0x38,0x03,0x64,
//        0x98,0x45,0xba,0x51,0xa6,

//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//        0xff,0xfe,0xe8,0xd5,0x22,0x4c,0xb0,0x22,0x41,0x06,0x04,0x09,0x3a,0x44,0x09,0x33,
//        0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x58,0xa8,0x50,0xa0,0x50,0xa8,0x48,0x58,
//        0xa6,0xda,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x09,0x06,0x09,0x32,0x05,
//        0x19,0x26,0x12,0x0c,0x09,0x02,0x01,0x00,0x00,0x10,0x2c,0x49,0x22,0x99,0x66,0xa9,
//        0x52,0xed,0xda,0xf5,0xfa,
// };


// void halLCD_send (uint8_t data)
// {
// //     uint8_t i;

// //     for (i = 0; i < 8; i++)
// //     {
// //         if (dat & 0x80)
// //         {
// //             PIN_LCD_DAT_H;
// //         }
// //         else
// //         {
// //             PIN_LCD_DAT_L;
// //         }
// //         dat = dat << 1;//Сдвиг внутри такта
// //         PIN_LCD_CLK_H;
// //         PIN_LCD_CLK_L;
// //     }
//     halSPI2_xput (data);
// }

#define halLCD_send(a)  halSPI2_xput(a)


void halLCD_inverse_mode (void)
{
    PIN_LCD_CS_L;
    PIN_LCD_RS_L;
    halLCD_send (0x0D); //B00001100 - {inverse video mode} D=1 E=1
    PIN_LCD_CS_H;
}


void halLCD_sleep (void)
{
    PIN_LCD_CS_L;
    PIN_LCD_RS_L;
    halLCD_send (0x24);
    PIN_LCD_CS_H;
}


void halLCD_init (uint8_t mode)
{   
    GPIOB->CRH |=  (GPIO_CRH_MODE12 |
        GPIO_CRH_MODE13 |
        GPIO_CRH_MODE14 |
        GPIO_CRH_MODE15);
    GPIOB->CRH &= ~(GPIO_CRH_CNF12 |
        GPIO_CRH_CNF13 |
        GPIO_CRH_CNF14 |
        GPIO_CRH_CNF15);
    
    
    PIN_LCD_RESET_L;
    PIN_LCD_CS_H;
    PIN_LCD_RS_L;
    PIN_LCD_CLK_L;
    PIN_LCD_DAT_L;
    
    halSPI2_init (0);
    
    _delay_ms (10);
    PIN_LCD_RESET_H;
    _delay_ms (10);
    
    LCD_pixel_mode = mode;
    
    //http://www.nxp.com/documents/data_sheet/PCF8812_2.pdf
    
    PIN_LCD_CS_L;
    PIN_LCD_RS_L;
    halLCD_send (0x21); //{H=1} Enter to extended instruktions PD=0 V=0 H=1 power-down control; entrymode; extended
    halLCD_send (0x06);  //B00000110 - {TEMP 0-3} Temperature coeficient TC1=1 TC0=0
    halLCD_send (0x0A);  //B00001010 - {Voltage Multiplier 0-3} S1=0 S0=1
    halLCD_send (0x13);  //B00010011 - {BIAS 0-7} BS2=1 BS1=1 BS0=0
    halLCD_send (0xE2);  //B11100010 - VOLTAGE 0-127 Vop=1100000
    halLCD_send (0x20); //{H=0}
    halLCD_send (0x0C); //B00001100 - {normal mode} D=1 E=0
    halLCD_send (0x11); //{PRS=0 VLcd = 2.94V to 6.75V}!!!
    PIN_LCD_CS_H;
    
    //halLCD_inverse_mode ();
    //contrast 0x80 | arg >>1
}



//-------------------------------------------------
//inline 
void _LCD_spiWrite (uint8_t byte)
{
/**
#else
    //while(!SPI1STATbits.SPIRBF); //while (0 != SPI1STATbits.SPITBF){}; // wait until bus cycle complete
    SPI2BUF = byte;    // write byte to SSP1BUF register
    while(!SPI2STATbits.SPIRBF); //while (0 != SPI1STATbits.SPIRBF){};
    return SPI2BUF;
#endif 
*/
}


void _LCD_setContrast (uint8_t val)
{
    if (val > 0x7F)
    {
        val = 0x7F;
    }
}


void halLCD_update_partial (void)
{
    uint8_t i, j;

    PIN_LCD_CS_L;
    if (++LCD_update_pos >= (LCD_H/8))
      LCD_update_pos = 0;
    PIN_LCD_RS_L;
    halLCD_send (0x80); //{X=0}
    halLCD_send (0x40 + (7 - LCD_update_pos));
    PIN_LCD_RS_H;
    for (i = 0; i < LCD_W; i++ )
    {
        halLCD_send (LCD_buf[i][LCD_update_pos]);
    }
    PIN_LCD_CS_H;
}

// void halLCD_update_all (void)
// {
//     halLCD_update_partial ();
//     halLCD_update_partial ();
//     halLCD_update_partial ();
//     halLCD_update_partial ();
//     halLCD_update_partial ();
//     halLCD_update_partial ();
//     halLCD_update_partial ();
//     halLCD_update_partial ();
// }

// void halLCD_picture (void)
// {
//     uint8_t i, j;
//     uint8_t *pBuf = (uint8_t *)&picture[0];
//     
//     for (j = 0; j < 8; j++)
//     {
//         for (i = 0; i < 101; i++)
//         {
//             LCD_buf[i][j] = *pBuf++;
//         }
//     }
// }













void paint_pixel_ (uint8_t x, uint8_t y, uint8_t val)
{
    uint8_t tmp8;
    uint8_t pix;
    char  y0;
        
    if ((x < LCD_W) && (y < LCD_H))
    {
        y0 = y & 0x07; 
        y = y >> 3;
        tmp8 = LCD_buf[x][y];
        switch (LCD_pixel_mode)
        {
            case GDI_ROP_COPY:	tmp8 = val;  break;
            case GDI_ROP_XOR:	tmp8 ^=  (val << y0); break; //inv
            case GDI_ROP_AND:	tmp8 &= ~(val << y0); break; //clr
            case GDI_ROP_OR:	tmp8 |=  (val << y0); break; //set
        }
        LCD_buf[x][y] = tmp8;
    }
}


void halLCD_setPixel (coord_t x, coord_t y)
{
    paint_pixel_ ((uint8_t)x, (uint8_t)y, 0x01);
}


void     halLCD_setPixelColor (coord_t x, coord_t y, color_t color)
{
    uint8_t tmp8;
    uint8_t pix;
    char  y0;
        
    if ((x < LCD_W) && (y < LCD_H))
    {
        y0 = y & 0x07; 
        y = y >> 3;
        tmp8 = LCD_buf[x][y];
        if (COLOR_WHITE == color)
            tmp8 &= ~(1 << y0); //clr
        else
            tmp8 |=  (1 << y0); //set
        LCD_buf[x][y] = tmp8;
    }
}


color_t halLCD_getPixel (coord_t x, coord_t y)
{
    uint8_t tmp8;
    uint8_t pix = 0x00;
    char  y0;
        
    if ((x < LCD_W) && (y < LCD_H))
    {
        y0 = y & 0x07;
        y = y >> 3;
        tmp8 = LCD_buf[x][y];
        pix = tmp8 & (1 << y0);
        if (0 != pix)
            return COLOR_BLACK;
        else
            return COLOR_WHITE;
    }
    return COLOR_WHITE;    
}


void halLCD_repaint (void)
{
#if LCD_ENABLE_PARTIAL_UPDATE //update only 1/8
    halLCD_update_partial ();
#else
    halLCD_update_partial ();
    halLCD_update_partial ();
    halLCD_update_partial ();
    halLCD_update_partial ();
    halLCD_update_partial ();
    halLCD_update_partial ();
    halLCD_update_partial ();
    halLCD_update_partial ();
#endif
}


// clear everything
void halLCD_cls (color_t color)
{
    uint8_t i, j;
    
    for (j = 0; j < 8; j++)
    {
        for (i = 0; i < 101; i++)
        {
            LCD_buf[i][j] = 0x00;
        }
    }
}


// массив всегда заполняется слева направао и с верху в низ
void     halLCD_fillBlock (coord_t x, coord_t y,
    uint16_t w, 
    uint16_t h, 
    color_t *buf)
{
    coord_t xx, yy;
    
    for (xx = 0; xx < w; xx++)
        for (yy = 0; yy < h; yy++)
            halLCD_setPixelColor (x + xx, y + yy, *buf++);
}


void     halLCD_fillBlockColor (coord_t x, coord_t y,
    uint16_t w,
    uint16_t h,
    color_t color)
{
    coord_t xx, yy;
    
    for (xx = 0; xx < w; xx++)
        for (yy = 0; yy < h; yy++)
            halLCD_setPixelColor (x + xx, y + yy, color);
}


void halLCD_setOrientation (uint8_t orient)
{
}

#endif //LCD_PCD8812
